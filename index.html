<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Tic‚ÄëTac Rush ‚Äì Mobile</title>

<style>
  :root{
    --bg:#0b0f1a; --panel:#12182a; --grid:#e8eaf1; --text:#e9ecf8;
    --void:#1f2937; --accent:#8b9dff; --accent2:#ffb86b; --good:#35d49a; --bad:#ff6b6b;
  }
  *{box-sizing:border-box}
  body {
    margin: 0;
    height: 100dvh;
    display: grid;
    place-items: center;
    overflow: hidden;
    /* üí• odstranƒõn tmav√Ω p≈ôechod ‚Äì l√°va plnƒõ viditeln√° */
    background: url("lava.webp") center/cover no-repeat;
    color: var(--text);
    font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial;
  }

  .wrap {
    display: grid;
    gap: 10px;
    align-items: center;
    justify-items: center;
    margin-top: 8vh;
  }

  #hud {
    display: flex;
    gap: 8px;
    justify-content: center;
    align-items: center;
    flex-wrap: wrap;
    background: rgba(18,24,42,.9);
    padding: 8px 10px;
    border-radius: 12px;
    box-shadow: 0 6px 20px rgba(0,0,0,.25);
    font-weight: 600;
    min-height: 38px;
  }
  #hud .badge {
    padding: 5px 9px;
    border-radius: 999px;
    background: #202846;
    font-weight: 700;
    font-size: .85rem;
  }
  
#board {
  width: min(96vw, 520px);
  aspect-ratio: 1 / 1;
  display: grid;
  grid-template-columns: repeat(var(--size, 11), 1fr);
  grid-template-rows: repeat(var(--size, 11), 1fr);
  gap: 2px;
  background: transparent; /* üí• zcela pr≈Øhledn√© pozad√≠ */
  padding: 6px;
  border-radius: 16px;
  box-shadow: 0 0 25px rgba(0,0,0,0.4); /* jen jemn√Ω vnƒõj≈°√≠ st√≠n */
}


  .cell {
    width: 100%;
    height: 100%;
    background: var(--grid);
    border-radius: 10px;
    display: grid;
    place-items: center;
    font-weight: 800;
    font-size: clamp(12px, 3.2vw, 22px);
    color: #111827;
    user-select: none;
    cursor: pointer;
    transition: filter .2s ease, background .2s ease, opacity .4s ease, box-shadow .2s ease;
  }
  .cell:hover { filter: brightness(.96); }
  .cell.void {
    background: transparent; /* üî• propadl√° bu≈àka ‚Äì l√°va vidƒõt */
    color: transparent;
    cursor: not-allowed;
    box-shadow: none;
  }
  .cell.selected {
    box-shadow: 0 0 0 3px var(--accent2) inset, 0 0 0 2px var(--accent2);
  }

  /* üí• Nov√° ≈æhav√° animace ‚Äì skuteƒçnƒõ pulzuje */
  @keyframes lava-fall {
    0% {
      background: var(--grid);
      transform: scale(1);
      opacity: 1;
      box-shadow: none;
    }
    25% {
      background: #ffb347;
      transform: scale(1.1);
      box-shadow: 0 0 20px 8px rgba(255, 100, 0, 0.8);
      opacity: 1;
    }
    50% {
      background: #ff2400;
      transform: scale(1.2);
      box-shadow: 0 0 45px 12px rgba(255, 30, 0, 1);
      opacity: 1;
    }
    75% {
      background: #ff6600;
      transform: scale(1.05);
      box-shadow: 0 0 30px 10px rgba(255, 90, 0, 0.9);
      opacity: 0.6;
    }
    100% {
      background: transparent;
      transform: scale(0.8);
      opacity: 0;
      box-shadow: none;
    }
  }

  .cell.falling {
    animation: lava-fall 1.4s ease-in-out forwards;
  }

  .card {
    width: min(96svw,520px);
    background: var(--panel);
    border-radius: 14px;
    padding: 12px 14px;
    text-align: left;
    box-shadow: 0 8px 24px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.06);
  }

  .small { font-size: .95rem; opacity: .9; }

  .overlay {
    position: fixed;
    inset: 0;
    display: grid;
    place-items: center;
    background: rgba(5,8,14,.65);
    backdrop-filter: blur(3px);
  }

  .popup {
    width: min(92svw,520px);
    background: var(--panel);
    border-radius: 16px;
    padding: 18px;
    text-align: center;
    box-shadow: 0 10px 30px rgba(0,0,0,.4), inset 0 0 0 1px rgba(255,255,255,.06);
  }

  h1 { margin: 6px 0 10px; font-size: clamp(20px,4.2svw,28px); }
  .row { display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 12px; }
  button {
    background: linear-gradient(180deg,#5f70ff,#4758f0);
    color: #fff;
    border: 0;
    border-radius: 12px;
    padding: 10px 14px;
    font-weight: 700;
    cursor: pointer;
    box-shadow: 0 8px 18px rgba(95,112,255,.35);
  }
  .btn-ghost { background:#222a45; box-shadow:none; }
  .hidden { display:none; }
</style>


</head>
<body>
  <div class="wrap">
    <div id="hud" class="hidden">
      <span class="badge" id="turnInfo">Turn: you ‚úñÔ∏è</span>
      <span class="badge" id="timeInfo">Time: 00:00</span>
      <span class="badge" id="movesInfo">Moves: 0</span>
    </div>

    <div id="board"></div>

<div class="info-slot">
  <div class="card small" id="howCard">
    <b>How to play</b>
    <p style="margin-top:6px">
      ‚Ä¢ Tap a tile to <b>select</b>. Tap again to <b>confirm</b>.<br>
      ‚Ä¢ Make <b>5 in a row</b> (row / column / diagonal).<br>
      ‚Ä¢ Tiles disappear at random during the game.<br>
    </p>
  </div>
</div>


  <div id="gameOver" class="overlay hidden">
    <div class="popup">
      <h1 id="resultTitle">Game over</h1>
      <p id="resultDesc" class="small"></p>
      <div class="row">
        <button id="againBtn">Play again</button>
        <button id="bonusBtn" class="btn-ghost">Bonus: see next drop</button>
      </div>
    </div>
  </div>

<script>
  // ===== Config
  const SIZE = 11; const WIN = 5;
  const PLAYER = 1, AI = 2, VOID = -1;
  const BASE_SHRINK_INTERVAL = 4; // one random drop every N half-moves

  // ===== State
  let grid=[], gameActive=false, playerTurn=true;
  let shrinkInterval=BASE_SHRINK_INTERVAL, turnsUntilShrink=BASE_SHRINK_INTERVAL;
  let nextFall=null, previewNextGame=false, previewThisGame=false;
  let selected=null, movesCount=0, startTs=null, timerHandle=null, winningLine=null;

  // ===== DOM
  const boardEl = document.getElementById('board');
  const hudEl = document.getElementById('hud');
  const turnInfoEl = document.getElementById('turnInfo');
  const timeInfoEl = document.getElementById('timeInfo');
  const movesInfoEl = document.getElementById('movesInfo');
  const howCard = document.getElementById('howCard');
  const gameOver = document.getElementById('gameOver');
  const resultTitle = document.getElementById('resultTitle');
  const resultDesc = document.getElementById('resultDesc');
  const againBtn = document.getElementById('againBtn');
  const bonusBtn = document.getElementById('bonusBtn');

  againBtn.addEventListener('click', ()=>{ gameOver.classList.add('hidden'); startGame(); });
  bonusBtn.addEventListener('click', ()=>{
    previewNextGame = true; bonusBtn.disabled = true;
    resultDesc.textContent = 'Bonus ready: see next drop next game.';
    againBtn.textContent = 'Play with bonus';
  });

  // ===== Init
  function setupBoardGrid(){
    boardEl.style.setProperty('--size', SIZE);
    boardEl.innerHTML='';
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const d=document.createElement('div');
        d.className='cell'; d.dataset.x=x; d.dataset.y=y;
        d.addEventListener('click', onCellClick);
        boardEl.appendChild(d);
      }
    }
  }

  function startGame(){ initState(); }

  function initState(){
    grid = Array.from({length: SIZE}, ()=>Array(SIZE).fill(0));
    previewThisGame = previewNextGame; previewNextGame = false; // consume bonus
    shrinkInterval = BASE_SHRINK_INTERVAL;
    turnsUntilShrink = shrinkInterval;
    playerTurn = true; gameActive = true;
    selected = null; movesCount = 0; startTs = null; winningLine = null;
    stopTimer(); timeInfoEl.textContent = 'Time: 00:00'; movesInfoEl.textContent = 'Moves: 0';
    hudEl.classList.remove('hidden');
    nextFall = pickNextFallTile();
    updateHUD();
    renderAll();
  }

  // ===== Helpers
  function inBounds(x,y){ return x>=0 && x<SIZE && y>=0 && y<SIZE; }
  function pickNextFallTile(){
    const c=[]; for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++) if(grid[y][x]!==VOID) c.push({x,y});
    if(!c.length) return null; return c[Math.floor(Math.random()*c.length)];
  }
  function formatTime(ms){ const s=Math.floor(ms/1000), m=Math.floor(s/60), r=s%60; return (m<10?'0':'')+m+':' + (r<10?'0':'')+r; }
  function startTimer(){ if(timerHandle) return; startTs=Date.now(); timerHandle=setInterval(()=>{ timeInfoEl.textContent='Time: '+formatTime(Date.now()-startTs); },250); }
  function stopTimer(){ if(timerHandle){ clearInterval(timerHandle); timerHandle=null; } }

  // ===== Render
  function renderAll(){
    const cells = boardEl.children;
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const idx=y*SIZE+x, el=cells[idx], v=grid[y][x];
        el.className='cell';
        if(v===VOID){ el.classList.add('void'); el.textContent=''; }
        else if(v===PLAYER){ el.classList.add('x'); el.textContent='‚úñÔ∏è'; }
        else if(v===AI){ el.classList.add('o'); el.textContent='‚óØ'; }
        else { el.textContent=''; }
        if(previewThisGame && nextFall && nextFall.x===x && nextFall.y===y && v!==VOID) el.classList.add('willFall');
        if(selected && selected.x===x && selected.y===y) el.classList.add('selected');
      }
    }
  }

  function updateHUD(){
    turnInfoEl.textContent = 'Turn: ' + (playerTurn ? 'you ‚úñÔ∏è' : 'bot ‚óØ');
    movesInfoEl.textContent = 'Moves: ' + movesCount;
  }

  // ===== Interaction (two-tap confirm)
  function onCellClick(e){
    if(!gameActive || !playerTurn) return;
    const x=+e.currentTarget.dataset.x, y=+e.currentTarget.dataset.y;
    if(!inBounds(x,y) || grid[y][x]!==0) return;

    if(howCard && !howCard.classList.contains('hidden')) howCard.classList.add('hidden');

    if(!selected || selected.x!==x || selected.y!==y){ selected={x,y}; renderAll(); return; }

    // confirm
    place(x,y,PLAYER); movesCount++; updateHUD(); if(movesCount===1) startTimer(); selected=null;
    if(checkWin(PLAYER)){ endGame(true); return; }
    advanceShrink(); if(!gameActive) return;
    playerTurn=false; updateHUD();
    setTimeout(()=>{ aiMove(); if(gameActive){ advanceShrink(); playerTurn=true; updateHUD(); } },120);
  }

  function place(x,y,who){ grid[y][x]=who; renderAll(); }

  // ===== Random drop
  function advanceShrink(){
    turnsUntilShrink--; renderAll();
    if(turnsUntilShrink<=0){ performFall(); turnsUntilShrink=shrinkInterval; renderAll(); }
  }

function performFall() {
  if (!nextFall) return;
  const { x, y } = nextFall;
  if (inBounds(x, y)) {
    const idx = y * SIZE + x;
    const el = boardEl.children[idx];
    el.classList.add('falling');
    boardEl.classList.add('shake'); // üí• jemn√Ω ot≈ôes
    setTimeout(() => boardEl.classList.remove('shake'), 200);
    setTimeout(() => {
      grid[y][x] = VOID;
      renderAll();
    }, 1100);
  }
  nextFall = pickNextFallTile();
}


  // ===== Win / Draw
  function checkWin(who){
    const dirs=[[1,0],[0,1],[1,1],[1,-1]];
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
      if(grid[y][x]!==who) continue;
      for(const [dx,dy] of dirs){
        let cells=[{x,y}], i=1;
        while(cells.length<WIN){ const nx=x+dx*i, ny=y+dy*i; if(!inBounds(nx,ny) || grid[ny][nx]!==who) break; cells.push({x:nx,y:ny}); i++; }
        if(cells.length>=WIN){ winningLine=cells; return true; }
      }
    }
    // full board -> draw
    for(let yy=0; yy<SIZE; yy++){ for(let xx=0; xx<SIZE; xx++){ if(grid[yy][xx]===0) return false; } }
    return true;
  }

function endGame(playerWon) {
  gameActive = false;
  stopTimer();

  // zv√Ωrazn√≠ v√Ωhern√≠ ≈ôadu
  if (winningLine && winningLine.length) {
    const cells = boardEl.children;
    for (const { x, y } of winningLine) {
      cells[y * SIZE + x].classList.add('win');
    }

    // üîπ kr√°tk√© bliknut√≠ cel√© v√Ωhern√≠ linie p≈ôed Game Over
    setTimeout(() => {
      for (const { x, y } of winningLine) {
        const el = cells[y * SIZE + x];
        el.animate(
          [
            { opacity: 1 },
            { opacity: 0.3 },
            { opacity: 1 }
          ],
          { duration: 500, easing: 'ease-in-out' }
        );
      }
    }, 900); // zaƒçne blikat tƒõsnƒõ p≈ôed koncem
  }

  // üîπ poƒçkej, ne≈æ efekt dobƒõhne ‚Üí pak Game Over popup
  setTimeout(() => {
    gameOver.classList.remove('hidden');
    bonusBtn.disabled = false;
    againBtn.textContent = 'Play again';

    if (playerWon === true) {
      resultTitle.textContent = 'You win!';
      const total = startTs ? formatTime(Date.now() - startTs) : '00:00';
      resultDesc.textContent = 'Time: ' + total + ' ‚Ä¢ Moves: ' + movesCount;
    } else if (playerWon === false) {
      resultTitle.textContent = 'You lose';
      resultDesc.textContent = 'No score this time. Try again!';
    } else {
      resultTitle.textContent = 'Draw';
      resultDesc.textContent = 'No more free tiles.';
    }
  }, 1500);
}

  // ===== Simple AI
 function aiMove(){
  const move = pickBestMove();
  if(!move){ endGame(null); return; }
  place(move.x, move.y, AI);

  // üîπ p≈ôid√°me kr√°tk√© pulznut√≠
  const idx = move.y * SIZE + move.x;
  const el = boardEl.children[idx];
  el.animate([
    { transform: 'scale(1)', opacity: 1 },
    { transform: 'scale(1.25)', opacity: 0.8 },
    { transform: 'scale(1)', opacity: 1 }
  ], { duration: 300, easing: 'ease-out' });

  if(checkWin(AI)){ endGame(false); }
}

  function pickBestMove(){
    let best=null, bestScore=-Infinity;
    for(let y=0;y<SIZE;y++) for(let x=0;x<SIZE;x++){
      if(grid[y][x]!==0) continue;
      const aiLen=projectedLineLen(x,y,AI), plLen=projectedLineLen(x,y,PLAYER);
      const centerBonus=-(Math.abs((SIZE-1)/2-x)+Math.abs((SIZE-1)/2-y))*0.03;
      const dangerPenalty=(previewThisGame && nextFall && nextFall.x===x && nextFall.y===y && turnsUntilShrink<=1)?-5:0;
      const score=aiLen*2.2 + plLen*2.0 + centerBonus + dangerPenalty;
      if(score>bestScore){ bestScore=score; best={x,y}; }
    }
    return best;
  }

  function projectedLineLen(x,y,who){
    let maxLen=1; const dirs=[[1,0],[0,1],[1,1],[1,-1]];
    for(const [dx,dy] of dirs){
      let cnt=1, i=1; while(true){ const nx=x+dx*i, ny=y+dy*i; if(!inBounds(nx,ny) || grid[ny][nx]!==who) break; cnt++; i++; }
      i=1; while(true){ const nx=x-dx*i, ny=y-dy*i; if(!inBounds(nx,ny) || grid[ny][nx]!==who) break; cnt++; i++; }
      if(cnt>maxLen) maxLen=cnt;
    }
    return maxLen;
  }

  // boot
  setupBoardGrid();
  startGame();
</script>
</body>
</html>
